#! /usr/bin/env node

import { execSync } from "node:child_process";
import crypto from "node:crypto";
import { promises as fs, mkdirSync } from "node:fs";
import * as path from "node:path";
import { glob } from "glob";
import { parse } from "node-html-parser";
import { loadConfig, optimize } from "svgo";

const cwd = process.cwd();
const inputDir = path.join(cwd, "other", "svg-icons");
const inputDirRelative = path.relative(cwd, inputDir);
const outputDir = path.join(cwd, "public");
const outputSrcDir = path.join(cwd, "src", "icons");
const outputIconHrefFile = path.join(cwd, "src", "components", "icon.tsx");
const outputIconPattern = /^sprite\.[a-f0-9]{3,64}\.svg$/; // Matches sprite.***.svg where *** is a hex digest
const shouldOptimize = true;

const files = glob
  .sync("**/*.svg", {
    cwd: inputDir,
  })
  .sort((a, b) => a.localeCompare(b));

const shouldVerboseLog = process.argv.includes("--log=verbose");
const logVerbose = shouldVerboseLog
  ? console.log
  : () => {
      // do nothing
    };

if (files.length === 0) {
  console.log(`No SVG files found in ${inputDirRelative}`);
} else {
  await generateIconFiles();
}

async function generateIconFiles() {
  mkdirSync(outputDir, { recursive: true });
  mkdirSync(outputSrcDir, { recursive: true });
  const spriteFilepath = path.join(outputDir, "sprite");
  const typeOutputFilepath = path.join(outputSrcDir, "name.d.ts");
  const currentSprite = await fs
    .readFile(spriteFilepath, "utf8")
    .catch(() => "");
  const currentTypes = await fs
    .readFile(typeOutputFilepath, "utf8")
    .catch(() => "");

  const iconNames = files.map(file => iconName(file));

  const spriteUpToDate = iconNames.every(name =>
    currentSprite.includes(`id=${name}`),
  );
  const typesUpToDate = iconNames.every(name =>
    currentTypes.includes(`"${name}"`),
  );

  if (spriteUpToDate && typesUpToDate) {
    logVerbose(`Icons are up to date`);
    return;
  }

  logVerbose(`Generating sprite for ${inputDirRelative}`);

  const spriteChanged = await generateSvgSprite({
    files,
    inputDir,
    outputPath: spriteFilepath,
    shouldOptimize: shouldOptimize,
  });

  for (const file of files) {
    logVerbose("âœ…", file);
  }
  logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

  const stringifiedIconNames = iconNames.map(name => JSON.stringify(name));

  const typeOutputContent = `// This file is generated by bun run build:icons

export type IconName =
\t| ${stringifiedIconNames.join("\n\t| ")};
`;
  const typesChanged = await writeIfChanged(
    typeOutputFilepath,
    typeOutputContent,
    true,
  );

  logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

  const readmeChanged = await writeIfChanged(
    path.join(outputSrcDir, "README.md"),
    `# Icons

This directory contains SVG icons that are used by the app.

Everything in this directory is generated by \`bun run build:icons\`.
`,
    true,
  );

  if (spriteChanged || typesChanged || readmeChanged) {
    console.log(`Generated ${files.length} icons`);
  }
}

function iconName(file: string) {
  return file.replace(/\.svg$/, "");
}

/**
 * Creates a single SVG file that contains all the icons
 */
async function generateSvgSprite({
  files,
  inputDir,
  outputPath,
  shouldOptimize,
}: {
  files: Array<string>;
  inputDir: string;
  outputPath: string;
  shouldOptimize: boolean;
}) {
  // Each SVG becomes a symbol and we wrap them all in a single SVG
  const symbols = await Promise.all(
    files.map(async file => {
      const input = await fs.readFile(path.join(inputDir, file), "utf8");
      const root = parse(input);

      const svg = root.querySelector("svg");
      if (!svg) throw new Error("No SVG element found");

      svg.tagName = "symbol";
      svg.setAttribute("id", iconName(file));
      svg.removeAttribute("xmlns");
      svg.removeAttribute("xmlns:xlink");
      svg.removeAttribute("version");
      svg.removeAttribute("width");
      svg.removeAttribute("height");

      return svg.toString().trim();
    }),
  );

  let output = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<!-- This file is generated by bun run build:icons -->`,
    `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
    `<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
    ...symbols,
    `</defs>`,
    `</svg>`,
    "", // trailing newline
  ].join("\n");

  if (shouldOptimize) {
    const config = (await loadConfig()) || { plugins: [] };
    if (!config.plugins) {
      config.plugins = [];
    }
    config.plugins.push({
      name: "preset-default",
      params: {
        overrides: {
          removeHiddenElems: false,
          cleanupIds: false,
          convertPathData: {
            floatPrecision: 5,
          },
        },
      },
    });
    output = optimize(output, config).data;
  }

  // Defining the algorithm
  const algorithm = "sha256";

  // Creating the digest in base64 encoding
  let digest = crypto.createHash(algorithm).update(output).digest("hex");

  // shorten digest to 10 characters
  digest = digest.slice(0, 10);

  const newFileName = `${outputPath}.${digest}.svg`;

  // Remove all old sprites from public folder
  if (await willChange(newFileName, output)) {
    const files = await fs.readdir(outputDir);

    for (const file of files) {
      if (outputIconPattern.test(file)) {
        const filePath = path.join(outputDir, file);
        await fs.unlink(filePath);
      }
    }
  }

  const changed = await writeIfChanged(newFileName, output);

  // Now update component's Href
  let content = await fs.readFile(outputIconHrefFile, "utf-8");
  const regex = /const IconHref = "\/sprite\.[a-f0-9]{3,64}\.svg";/;

  if (regex.test(content)) {
    content = content.replace(
      regex,
      `const IconHref = "/sprite.${digest}.svg";`,
    );
    await fs.writeFile(outputIconHrefFile, content, "utf-8");
  }

  return changed;
}

async function willChange(filepath: string, newContent: string) {
  const currentContent = await fs.readFile(filepath, "utf8").catch(() => "");
  return currentContent !== newContent;
}

async function writeIfChanged(
  filepath: string,
  newContent: string,
  format = false,
) {
  if (!(await willChange(filepath, newContent))) {
    return false;
  }
  await fs.writeFile(filepath, newContent, "utf8");
  if (format) {
    execSync(`bunx @biomejs/biome format --write ${filepath}`);
  }
  return true;
}
